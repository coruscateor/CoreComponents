//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3607
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using CoreComponents.Text;

namespace CoreComponents.Application
{

    //I need to serously recosider my approach

	public class ProcessController<TArgs> : IDisposable where TArgs : IText 
	{

		public event Gimmie<SenderEventArgs<ProcessController<TArgs>>>.GimmieSomethin Entered;
		
		public event Gimmie<SenderEventArgs<ProcessController<TArgs>>>.GimmieSomethin Exited;
		
		public event Gimmie<ChangeEventArgs<DataReceivedEventArgs, ProcessController<TArgs>>>.GimmieSomethin ErrorDataReceived;
		
		public event Gimmie<ChangeEventArgs<DataReceivedEventArgs, ProcessController<TArgs>>>.GimmieSomethin OutputDataReceived;
		
		//public event EventHandler Disposed;
		
		Process myProcess;
		
		ProcessStartInfo myInfo = new ProcessStartInfo();
		
		bool myIsActive;
		
		protected TArgs myArgs;

        static int statNoOfProcesses;

        //int myProcID;
        /*
        static ProcessController()
        {

            Process.EnterDebugMode();

        }
        */
        /*
        static void stat_Increment()
        {

            if (statNoOfProcesses == 0)
            {

                Process.EnterDebugMode();

            }

            statNoOfProcesses++;

        }

        static void stat_DeIncrement()
        {

            statNoOfProcesses--;

            if (statNoOfProcesses == 0)
            {

                Process.LeaveDebugMode();

            }

        }
        */

		public ProcessController()
		{

			//myProcess = new Process();

            myInfo.UseShellExecute = false;

            myInfo.CreateNoWindow = false;

            myInfo.RedirectStandardOutput = true;

            myInfo.RedirectStandardError = true;

            //myProcess.EnableRaisingEvents = true;

            //stat_Increment();
			
			//Subscribe();
			
		}
		
		public string File
		{
			set
			{
				
				myInfo.FileName = value;
					
			}
			get
			{
				
				return myInfo.FileName;
				
			}
			
		}
		
		void OnEntered()
		{
			
			myIsActive = true;
			
			if(Entered != null)
				Entered(new SenderEventArgs<ProcessController<TArgs>>(this));
			
		}
		
		void OnExited()
		{
			
			myIsActive = false;
			
			if(Exited != null)
				Exited(new SenderEventArgs<ProcessController<TArgs>>(this));
			
		}
		
		void OnErrorDataReceived(DataReceivedEventArgs Item)
		{
			
			if(ErrorDataReceived != null)
				ErrorDataReceived(new ChangeEventArgs<DataReceivedEventArgs, ProcessController<TArgs>>(this, Item));
			
		}
		
		void OnOutputDataReceived(DataReceivedEventArgs Item)
		{
			
			if(OutputDataReceived != null)
				OutputDataReceived(new ChangeEventArgs<DataReceivedEventArgs, ProcessController<TArgs>>(this, Item));
			
		}
		
		protected void Subscribe()
		{
			
			myProcess.ErrorDataReceived += MyProcessErrorDataReceived;
			
			myProcess.Exited += MyProcessExited;
			
			myProcess.OutputDataReceived += MyProcessOutputDataReceived;
			
			//myProcess.Disposed += MyProcessDisposed;
			
		}

		void MyProcessDisposed (object sender, EventArgs e)
		{
			
		}

		void MyProcessOutputDataReceived(object sender, DataReceivedEventArgs e)
		{
		
			OnOutputDataReceived(e);	
			
		}

		void MyProcessExited(object sender, EventArgs e)
		{

            //try
            //{

                //myProcess.CancelErrorRead();

                //myProcess.CancelOutputRead();

            //} finally
            //{

                OnExited();

            //}
		}

		void MyProcessErrorDataReceived(object sender, DataReceivedEventArgs e)
		{
		
			OnErrorDataReceived(e);
			
		}
		
		protected void UnSubscribe()
		{
			
			myProcess.ErrorDataReceived -= MyProcessErrorDataReceived;
			
			myProcess.Exited -= MyProcessExited;
			
			myProcess.OutputDataReceived -= MyProcessOutputDataReceived;
			
			//myProcess.Disposed -= MyProcessDisposed;
			
		}
		
		public void Start()
		{
			
			//myProcess = new Process();
			//Ear arse Invalid operation exception.
			//if(myProcess.HasExited) {
			
			if(!myIsActive) {
			
				//myInfo.Arguments = myArgs.ToString();
			
				//myProcess.StartInfo = myInfo;

                try
                {

                    //myProcess.Start();

                    myInfo.Arguments = myArgs.ToString();

                    //myInfo.

                    myProcess = Process.Start(myInfo);

                    //myProcess.Kill();

                    //myProcess.EnableRaisingEvents = true;

                    //Subscribe();

                    //myProcess.BeginOutputReadLine();

                    //myProcess.BeginErrorReadLine();

                    myProcess.Refresh();

                    //myProcID = myProcess.Id;

                    OnEntered();

                } catch(Exception e)
                {

                    //myProcess.CancelErrorRead();

                    //myProcess.CancelOutputRead();

					Stop();
					
					//myProcess.Kill();
                }

			}
			
		}
		
		public bool IsActive
		{
			get
			{
				
				return myIsActive;
					
			}
		}
		
		public void Stop()
		{
			
			myProcess.Refresh();
			
			if(myIsActive)
            //if (myProcess.HasExited) 
			{
				
				//myProcess.CancelErrorRead();
			
				//myProcess.CancelOutputRead();

                //myProcess.CloseMainWindow();
				//myProcess.Kill();
                //myProcess.WaitForExit(10);

               // myProcess.

                //myProcess.Close();

                //myProcess.CloseMainWindow();

                UnSubscribe();

                myProcess.Kill();

                myProcess.Close();

                //UnSubscribe();

                //Process.GetProcessById(myProcess.Id).Kill();

                //Process.GetProcessById(myProcID).Kill();

                //OnExited();
			    
				/*
				if(!myProcess.CloseMainWindow()) {
			
					myProcess.Kill();
			
				}
				*/
				
			}

		}

		public void Dispose()
		{

            //UnSubscribe();

            //myProcess.Close();

			Stop();

            //stat_DeIncrement();
			
		}
		
		public TArgs Args
		{
			
			get
			{
				
				return myArgs;
				
			}
			//set
			//{
				
			//}
			
		}

	}
	
	public class StringArgs : IText
	{
        //PCS 18062010
        //Don't know whats up with this but I wants me to assign explicitly
        //or it is NULL instead of "" like it should be.

        string myStringArgs = "";
		
		public StringArgs()
		{
			
		}
		
		public StringArgs(string Args)
		{
            myStringArgs = Args;
		}

        public string StrArgs
		{
			get
			{

                return myStringArgs;
				
			}
			set
			{

                myStringArgs = value;
				
			}
		}
		
		public override string ToString ()
		{
            return myStringArgs;
		}

		
	}
	
	
	public class ProcessController : ProcessController<StringArgs>
	{
		
		public ProcessController()
		{
            myArgs = new StringArgs();
		}
		
	}

	
}
